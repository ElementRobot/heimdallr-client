<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Heimdall-Client: Source: heimdallr-client.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: heimdallr-client.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/** @module heimdallrClient */

var io = require('socket.io-client');

var Client,
    Provider,
    Consumer;

/**
 * A Heimdallr packet is javascript object. It is how information is
 * transferred between the Heimdallr server and Heimdallr clients. The types
 * of packet are [event]{@link module:heimdallrClient~event},
 * [sensor]{@link module:heimdallrClient~sensor}, and
 * [control]{@link module:heimdallrCLient~control}.
 *
 * @typedef {object} packet
 */

/**
 * A Heimdallr event packet is a packet that originates from a
 * Provider and contains information about the state of the Provider. A
 * Consumer can listen for events by specifying &lt;tt>msgName&lt;/tt>
 * as &lt;tt>'event'&lt;/tt> when calling the
 * [on]{@link module:heimdallrClient~Client#on} function. A Heimdallr event
 * &lt;tt>t&lt;/tt> must be an
 * [ISO 8601]{@link http://en.wikipedia.org/wiki/ISO_8601} formatted string.
 * 
 * @typdef {object} event
 * @prop {string} t
 */

 /**
  * A Heimdallr sensor packet.
  *
  * @typedef {object} sensor
  */

 /**
  * A Heimdallr control packet.
  *
  * @typedef {object} control
  */

/**
 * Callback for socket.io messages.
 *
 * @callback msgCallback
 * @arg {} data - Data sent with the message.
 */

/**
 * The Client contructor takes an authentication token and
 * attempts to connect to the Heimdallr server using the token.
 *
 * @class
 * @classdesc Base class for Heimdallr clients.
 * @private
 * @arg {string} token - Authentication token, provider or consumer.
 * @return {Client} A new client object.
 */
function Client(token){
    this.ready = false;
    this.readyCallbacks = [];
    this.handlers = {};

    this.connection = new io.connect(this.url);
    this.connection.on('connect', function(){
        // If they want to authorize right off, let them
        this.connection.emit('authorize', {token: token});
        this.connection.on('auth-success', function callReady(){
            this.readyCallbacks.map(function(fn, i){
                fn();
            });
            this.readyCallbacks = [];
            this.ready = true;
        }.bind(this));
    }.bind(this));

    this.connection.on('err', function(err){
        throw new Error(err);
    });
}

/**
 * Add a socket.io message listener. A socket.io message is any communication
 * emitted by a socket.io client or server. Heimdallr
 * [packets]{@link module:heimdallrClient~packet} are a special instance
 * of a socket.io message.
 *
 * @method
 * @arg {string} msgName - Name of the socket.io event to listen for.
 * @arg {msgCallback} fn - [Callback]{@link module:heimdallrClient~msgCallback}
 *     to run when socket.io message is heard.
 * @return {Client} The original client object making it chainable.
 */
Client.prototype.on = function on(msgName, fn){
    if(msgName === 'ready'){
        onReady(fn)();
    }
    else {
        // connect and auth-success are protected
        if(msgName !== 'connect' &amp;&amp; msgName !== 'auth-success'){
            this.connection.removeListener(msgName);
        }
        this.connection.on(msgName, fn);
    }

    return this;
};

/**
 * @private
 * @prop {string} url - The URL of the Heimdallr server
 */
// Leave this as an undocumented backdoor for ourselves for the time being
Client.prototype.url = 'https://heimdallr.skyforge.co';


/**
 * The Provider contructor works in the same way as the Client constructor,
 * but it connects to the /provider namespace.
 *
 * @class
 * @classdesc Heimdallr provider class.
 * @extends Client
 * @arg {string} token - A provider authentication token.
 * @return {Provider} A new Provider object.
 */
function Provider(){
    this.url += '/provider';
    Client.apply(this, arguments);
}
Provider.prototype = Client.prototype;

// Couldn't get @inheritdoc working
/**
 * @see {@link module:heimdallrClient~Client#on}
 */
Provider.prototype.on = Provider.prototype.on;

/**
 * Sends an [event]{@link module:heimdallrClient~event} to the Heimdallr
 * server. The &lt;tt>event&lt;/tt> will be saved and then relayed to all
 * subscribed consumers. Must adhere to the provider's JSONSchema
 * for the &lt;tt>event&lt;/tt> subtype.
 * 
 * @method
 * @arg {string} name - The &lt;tt>event&lt;/tt> name.
 * @arg {json} value - The &lt;tt>event&lt;/tt> data.
 */
Provider.prototype.sendEvent = onReady(function sendEvent(name, value){
    var ev = {};
    ev[name] = value;
    ev.t = (new Date()).toISOString();
    this.connection.emit('event', ev);
});

/**
 * Sends a {sensor} to the Heimdallr server. The {sensor} will be
 * saved and then relayed to all subscribed consumers. Must adhere to
 * the provider's JSONSchema for the {sensor} type.
 * 
 * @method
 * @arg {string} name - The {sensor} name.
 * @arg {json} value - The {sensor} data.
 */
Provider.prototype.sendSensor = onReady(function sendSensor(name, value){
    var sensor = {};
    sensor[name] = value;
    sensor.t = (new Date()).toISOString;
    this.connection.emit('sensor', sensor);
});

/**
 * Sends binary data to the Heimdallr server. This should only be
 * used when the Heimdallr server has issued a &lt;tt>{'stream': 'start'}&lt;/tt>
 * control packet and should stop when the Heimdallr server has
 * issued a &lt;tt>{'stream': 'stop'}&lt;/tt> control packet. This data will be
 * relayed to all subscribed consumers who have also joined the
 * stream for this provider. This data will not be saved.
 * 
 * @method
 * @arg {any} data - The binary data to be sent.
 */
Provider.prototype.sendStream = onReady(function sendStream(data){
    this.connection.emit('stream', data);
});

/**
 * Tell Heimdallr server that the persistent {control} with id {uuid}
 * has been completed. A persistent {control} will be sent to a
 * provider when it is first issued, and again on every reconnect
 * until the provider signals that the {control} has been completed.
 *
 * @method
 * @arg {string} uuid - UUID of the persistent {control} that has been
 *     completed.
 */
Provider.prototype.completed = onReady(function completed(uuid){
    this.connection.emit('event', {
        'completed': uuid,
        't': (new Date()).toISOString()
    });
});


/**
 * The Consumer contructor works in the same way as the Client constructor,
 * but it connects to the /consumer namespace.
 *
 * @class
 * @classdesc Heimdallr consumer class.
 * @extends Client
 * @arg {string} token - A consumer authentication token.
 * @return {Consumer} A new Consumer object.
 */
function Consumer(){
    this.url += '/consumer';
    Client.apply(this, arguments);
}
Consumer.prototype = Client.prototype;

/**
 * @see {@link module:heimdallrClient~Client#on}
 */
Consumer.prototype.on = Client.prototype.on;

/**
 * Subscribe to a provider. A consumer must subscribe to a provider
 * before it receives {event}s or {sensor}s from the provider or can
 * send {control}s to the provider.
 *
 * @method
 * @arg {string} uuid - UUID of provider to subscribe to.
 */
Consumer.prototype.subscribe = onReady(function subscribe(uuid){
    this.connection.emit('subscribe', {provider: uuid});
});

/**
 * Unsubscribe from provider. This will be called automatically on
 * disconnect.
 * 
 * @method
 * @arg {string} uuid - UUID of provider to unsubscribe from.
 */
Consumer.prototype.unsubscribe = onReady(function unsubscribe(uuid){
    this.connection.emit('unsubscribe', {provider: uuid});
});

/**
 * Control which {event}s and {sensor}s to listen to.
 *
 * @method
 * @arg {string} uuid - UUID of provider to filter packets from.
 * @arg {object} filter - Object containg {event} and {sensor} packet
 *     types that you want to recieve. The keys can be 'event' and/or
 *     'sensor'. The values must be an array of {event} or {sensor}
 *     names.
 */
Consumer.prototype.setFilter = onReady(function setFilter(uuid, filter){
    filter = filter || {};
    if(!(filter.event instanceof Array) &amp;&amp; !(filter.data instanceof Array)){
        throw new Error(
            'Invalid filter'
        );
    }
    this.connection.emit('setFilter', {provider: uuid, filter: filter});
});

/**
 * Get the current state of a provider. For each {event} type
 * specified, the latest {event} of that type will be sent to the
 * consumer by the server.
 * 
 * @method
 * @arg {string} uuid - UUID of provider to get state for.
 * @arg {array} keys - array of {event} names to get.
 */
Consumer.prototype.getState = onReady(function getState(uuid, keys){
    this.connection.emit('getState', {provider: uuid, keys: keys});
});

/**
 * Send a {control} to a provider. Must adhere to the provider's
 * JSONSchema for the {control} type. If &lt;tt>persistent&lt;/tt> is true, a
 * persistent field will be included along with the {control} data.
 * The value of the persistent field will be a UUID that can be used
 * to signal the Heimdallr server that the {control} has been
 * completed. To do so, the provider must send a 'completed' {event}
 * with UUID included in the persistent field. The {control} will be
 * re-sent every time the provider re-connects to Heimdallr until
 * the Hiemdallr server has been told that it has been completed.
 *
 * @method
 * @arg {string} uuid - Provider to send {control}.
 * @arg {string} name - The {control} name.
 * @arg {json} value - The {control} data.
 * @arg {boolean} [persistent=false] - Whether or not the {control}
 *     should persist.
 */
Consumer.prototype.sendControl = onReady(function sendControl(uuid, name, value, persistent){
    var control = {provider: uuid};
    control[name] = value;
    if(persistent){
        control.persistent = true;
    }
    this.connection.emit('control', control);
});

/**
 * Join binary data stream from a provider. If this is the first
 * consumer to join the stream from a provider, the Heimdallr server
 * will send a &lt;tt>{"stream": "start"}&lt;/tt> {control} to the provider.
 * 
 * @method
 * @arg {string} uuid - UUID of provider to join stream for.
 */
Consumer.prototype.joinStream = onReady(function joinStream(uuid){
    this.connection.emit('joinStream', {provider: uuid});
});

/**
 * Leave binary data stream for a provider. If this is the last
 * consumer to leave the stream for a provider the Heimdallr server
 * will send a &lt;tt>{"stream": "stop"}&lt;/tt> {control} to the provider. This
 * will be called automatically on disconnect.
 *
 * @method
 * @arg {string} uuid - UUID of provider to leave stream for.
 */
Consumer.prototype.leaveStream = onReady(function leaveStream(uuid){
    this.connection.emit('leaveStream', {provider: uuid});
});


/**
 * Decorator that creates a function which will wait until the Client is
 * ready to to call the input &lt;tt>fn&lt;/tt>. Any calls to the decorated function
 * will check if the input client is ready. If it is ready, it will call
 * the function immediately. If it is not, it will add it to a
 * queue of callbacks that will be called once the Client is ready.
 * The Client is ready once it has connected to the Heimdallr
 * server and received an 'auth-success' socket.io event.
 * 
 * @func onReady
 * @private
 * @arg {function} fn - Function to decorate.
 * @return {function} The decorated function that will wait until
 *     the client is ready to trigger.
 */
function onReady(fn){
    return function(){
        var args = Array.prototype.slice.call(arguments);
        if(this.ready){
            fn.apply(this, args);
        }
        else {
            this.readyCallbacks.push(function(){
                fn.apply(this, args);
            });
        }
    };
}

module.exports = {
    Provider: Provider,
    Consumer: Consumer
};</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Heimdallr-Client</a></h2><h3>Modules</h3><ul><li><a href="module-heimdallrClient.html">heimdallrClient</a></li></ul><h3>Classes</h3><ul><li><a href="module-heimdallrClient-Client.html">Client</a></li><li><a href="module-heimdallrClient-Consumer.html">Consumer</a></li><li><a href="module-heimdallrClient-Provider.html">Provider</a></li></ul>
</nav>

<br class="clear">

<footer>
    ©2015 Element Robot LLC<br>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.3.0-beta1</a> on Fri Feb 27 2015 15:31:41 GMT-0800 (PST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
